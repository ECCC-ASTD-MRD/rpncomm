#!/bin/ksh93
# this script is the successor to the r.mpirun... series of scripts with expanded functionality
# (stdout/stderr post processing and "launch in background" capability)
#
# CAVEAT: this script uses typeset -Z (does not work for the bash shell)
typeset -Z4 SeqNum MemberNo MemberChild
# ===========================================================================
# start of temporary code to deal with OLD mpich2 versions needing mpdboot
#
kill_mpich2_mpd() {
  echo KILLING OLD INITIATORS IF ANY ARE FOUND
  for system in $(sort -u <${PBS_NODEFILE} | xargs) 
  do
    for target in $(ssh ${system}  ps -ef | grep /bin/mpd | grep python | grep ${USER} | sed -e s'/[ ][ ]*/ /g' | cut '-d ' -f 2) 
    do
      echo KILLING process ${target} on node ${system}
      ssh ${system} kill -9 ${target}
    done 
  done
}
start_mpich2_mpd() { # start mpd daemon(s)
  mpdboot -n $( sort -u <${PBS_NODEFILE} | wc -l ) -f ${PBS_NODEFILE}
  echo "mpd daemon(s) started"
}
stop_mpich2_mpd() {  # stop mpd daemon(s)
  mpdallexit
  echo "mpd daemon(s) stopped"
}
# ===========================================================================
# start of temporary code to deal with OLD mpich2 versions needing mpdboot
#
mpiexec_Linux() {
  export ENVIRONMENT_PASSED=yes
#  ((MpiCommWorlds>1)) && echo "ERROR: MpiCommWorlds>1 not supported yet" && return
#
# we are assuming that mpirun/mpiexec can be backgrounded.
# should this assumption be false the top line must be uncommented
#
# start of temporary code to deal with OLD mpich2 versions needing mpdboot
#
  mpirun --version 2>/dev/null 1>/dev/null || UseMpdboot=yes  # old mpich2 or no mpirun at all
  [[ -n $(which mpdboot 2>/dev/null) ]] || UseMpdboot=no      # mpdboot not found
  [[ "${UseMpdboot}" == yes ]] && echo "WARNING: using OLD version (pre 1.3) of mpich2 detected"
  [[ "${UseMpdboot}" == yes ]] && kill_mpich2_mpd     # needed temporarily for old mpich2 versions
  [[ "${UseMpdboot}" == yes ]] && start_mpich2_mpd    # needed temporarily for old mpich2 versions
#
# end of temporary code to deal with OLD mpich2 versions needing mpdboot
#
  if [[ "${OPAL_PREFIX}" == *openmpi_1.6* ]] ; then
    OPEN_MPI_PARMS="--prefix ${OPAL_PREFIX} --stdin all --mca btl tcp,self --cpus-per-proc ${OMP_NUM_THREADS:-1}"
    unset PE_HOSTFILE
#    export OMPI_MCA_orte_default_hostfile=${PBS_NODEFILE}
    [[ -f "${GECOSHEP_HOSTS_FILE}" ]] && export OMPI_MCA_orte_rsh_agent=rurun
    export OMPI_MCA_plm_rsh_disable_qrsh=1
  fi
#
  touch tmpdir/.mpi_env
  export MpiCommWorld=0
  export ChildOffset=0
  HostOffset=0
  PBS_NODEFILE_ORI=${PBS_NODEFILE}
  while(( MpiCommWorld<MpiCommWorlds)) ; do
#
    echo ===== MPI host file for MpiCommWorld=$MpiCommWorld =====
    ((FirstHost=HostOffset+1))
    ((HostOffset=HostOffset+${PeInWorld[${MpiCommWorld}]}))
    export PBS_NODEFILE=${PBS_NODEFILE_ORI}.${MpiCommWorld}
    sed -n ${FirstHost},${HostOffset}p ${PBS_NODEFILE_ORI} >${PBS_NODEFILE}
    cat ${PBS_NODEFILE}
    echo ===== MPI host file =====
#
    [[ "${OPAL_PREFIX}" == *openmpi_1.6* ]] && \
       env | grep -v "'" | grep -v '"' | grep  '^[a-zA-Z0-9]' | sed -e 's/^/export /' -e 's/=/="/' -e 's/$/"/' >tmpdir/.mpi_env
#
    if ((MpiCommWorlds>1)) ; then
      echo ==== Backgrounding MPI world ${MpiCommWorld} with ${PeInWorld[${MpiCommWorld}]} MPI tasks ====
      cat tmpdir/.mpi_env | \
      mpirun ${OPEN_MPI_PARMS} -machinefile ${PBS_NODEFILE} -n ${PeInWorld[${MpiCommWorld}]} "$@" ${ParallelScript}.${MpiCommWorld} &
    else
      echo ==== Launching MPI world ${MpiCommWorld} with ${PeInWorld[${MpiCommWorld}]} MPI tasks ====
      cat tmpdir/.mpi_env | \
      mpirun ${OPEN_MPI_PARMS} -machinefile ${PBS_NODEFILE} -n ${PeInWorld[${MpiCommWorld}]} "$@" ${ParallelScript}.${MpiCommWorld}
    fi
    PeAdded=${PeInWorld[${MpiCommWorld}]}
    ((ChildOffset=ChildOffset+PeAdded))
    ((MpiCommWorld=MpiCommWorld+1))
  done
  ((MpiCommWorlds>1)) && \
  echo ==== Waiting for ${MpiCommWorlds} MPI worlds to terminate ==== && \
  wait
#
  [[ "${UseMpdboot}" == yes ]] && stop_mpich2_mpd     # needed temporarily for OLD mpich2 versions that need mpdboot
}
#
mpiexec_AIX() {
  export ENVIRONMENT_PASSED=yes
#  ((MpiCommWorlds>1)) && echo "ERROR: MpiCommWorlds>1 not supported yet" && return
  ((MpiCommWorld=0))
  if tty -s ; then  # node list only necessary in interactive case
    echo "INFO: interactive use of MPI on AIX"
    export MP_PROCS
    export MP_HOSTFILE=${PBS_NODEFILE}
    grep -q $(hostname) ${HOME}/.rhosts 2>/dev/null || echo $(hostname) ${USER} >>${HOME}/.rhosts
    chmod 700 ${HOME}/.rhosts
  fi
  rm -f ${ParallelScript}.ALL
  ((MP_PROCS=0))
  while(( MpiCommWorld<MpiCommWorlds)) ; do
    echo "${ParallelScript}.${MpiCommWorld}@$((MpiCommWorld+1))%${PeInWorld[${MpiCommWorld}]}%mpi:*" >>${ParallelScript}.ALL
    ((MP_PROCS=MP_PROCS+${PeInWorld[${MpiCommWorld}]}))
    ((MpiCommWorld=MpiCommWorld+1))
  done
  export MP_NEWJOB=parallel
  export ChildOffset=0   # poe takes care of adjusting MP_CHILD
#  export MP_WORLD_SIZES=${PeInWorld[${MpiCommWorld}]}
#  poe "$@" ${ParallelScript}.${MpiCommWorld} </dev/null
  echo MP_PROCS=${MP_PROCS}
  echo "COMPLETE" >>${ParallelScript}.ALL
  echo "========== poe command file with ${MP_PROCS} tasks =========="
  cat ${ParallelScript}.ALL
  poe -cmdfile ${ParallelScript}.ALL </dev/null
  echo POE command COMPLETE
}
#
local_cleanup() {
 [[ -n ${nocleanup} ]] && return
 rm -f ${ParallelScript}* ${MP_HOSTFILE} ${MpiRunScript}* ${tmpdir}/PBS_NODEFILE* ${selftest} ${tmpdir}/.mpi_env*
 rmdir ${tmpdir} || true
 [[ -d "${tmpdir}" ]] && \
 echo INFO: leftovers found in ${tmpdir} && \
 ls -al ${tmpdir} && \
 rm -rf ${tmpdir}  && \
 echo removing everything in ${tmpdir}
}
#
print_separator() {
  [[ -n ${nosep} ]] && return
  echo ===================      "$@"      ===================
}
#
cat_output() {  #  cat captured stdout/stderr files into stdout with appropriate tagging
#
  Prefix3="${errp}-"
  Prefix2="${outp}${errp}-"   # prepare for stderr not split from stdout
  [[ "${spliteo}" == yes ]] && Prefix2="${outp}-"
  [[ "${tag}" == none    ]] && Prefix="" && Prefix2="" && Prefix3=""
  [[ "${tag}" == stderr  ]] && Prefix="" && Prefix2="" && Prefix3="stderr: "
  for SeqNum in $* ; do 
    ((MemberNo=SeqNum/npex+offset))
    ((MemberChild=SeqNum-SeqNum/npex*npex))
    [[ "${tag}" == full   ]] && Prefix="${MemberNo}-${MemberChild}: "
    [[ "${tag}" == member ]] && Prefix="${MemberNo}: "
    [[ "${tag}" == child  ]] && Prefix="${SeqNum}: "
    [[ -r ${SeqNum}/stdout ]] && print_separator start stdout ${MemberNo}:${MemberChild} && cat ${SeqNum}/stdout | sed -e "s/^/${Prefix2}${Prefix}/"
    [[ -r ${SeqNum}/stderr ]] && print_separator start stderr ${MemberNo}:${MemberChild} && cat ${SeqNum}/stderr | sed -e "s/^/${Prefix3}${Prefix}/"
  done
  print_separator "   stdout / stderr   "
  print_separator " end of parallel run "
#
}
#
clean_output() {   #  get rid of captured stdout/stderr files into stdout
#
  [[ -n ${nocleanup} ]] && return
  for SeqNum in $* ; do 
    rm -f ${SeqNum}/std*
    rmdir ${SeqNum}
  done
#
}
#
make_c_test() {
echo INFO: creating C test program source mpi_c_test.c
cat >${tmpdir}/mpi_c_test.c <<EOT
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <mpi.h>

void main(int argc, char **argv)
{
 int my_rank=-1;
 char hostname[1204];

 gethostname(hostname, 1023);
 MPI_Init(&argc,&argv);
 MPI_Comm_rank(MPI_COMM_WORLD , &my_rank);
 printf("host = %s, rank = %d \n",hostname,my_rank);
 MPI_Finalize();
}
EOT
echo INFO: compiling C test program mpi_c_test.c into mpi_c_test
which mpicc 2>/dev/null 1>/dev/null && mpicc -o ${tmpdir}/mpi_c_test ${tmpdir}/mpi_c_test.c
which mpcc 2>/dev/null 1>/dev/null && mpcc -o ${tmpdir}/mpi_c_test ${tmpdir}/mpi_c_test.c
echo INFO: removing C test program source mpi_c_test.c
rm ${tmpdir}/mpi_c_test.c
}
#
make_node_file() {
  rm -f $TMPDIR/PBS_NODEFILE
  if [[ -n ${PBS_NODEFILE} ]] ; then  # node list found
    nhosts=$(sort -u ${PBS_NODEFILE} | wc -l | sed 's/ .*//')   # number of hosts
    echo 
    ((loops=(npe_total+nhosts-1)/nhosts))   # number of tasks per host
    for i in `sort -u < $PBS_NODEFILE`
    do
      for j in $(seq $loops)
      do
	echo ${i} >>${TMPDIR}/PBS_NODEFILE   # one entry per task
      done
    done
  else
    if tty -s ; then   # no node list and interactive, create one
      ((npe_temp=npe_total))
      while (( npe_temp > 0 )) ; do ((npe_temp=npe_temp-1)) ; echo $(hostname) >> ${TMPDIR}/PBS_NODEFILE ; done
    fi
  fi
  export PBS_NODEFILE=$TMPDIR/PBS_NODEFILE
}
#
echo version avec /bin/ksh
eval `cclargs_lite $0 \
    -tmpdir "$(pwd -P)/tmpdir" "" "[temporary directory visible by all processes]" \
    -pgm "Invalid_Command.EXE" "" "[]" \
    -args "" "" "[arguments to the command]" \
    -inorder "" "yes" "[list out/err of members in process order]" \
    -processorder "" "yes" "[list out/err of members in order]" \
    -spliteo "no" "yes" "[split stderr from stdout]" \
    -npex "${BATCH_MPI_CPUS:-1}" "" "[member size, total number of cpus if 1 member]" \
    -npey "1" "" "[number of members]" \
    -nompi "run_with_mpi" "run_in_background" "[]" \
    -mpiargs "" "" "[]" \
    -geometry "" "" "[]" \
    -debug "" "part" "[]" \
    -nocleanup "" "nocleanup" "[]" \
    -tag "child" "full" "[full/child/member/stderr/none]" \
    -outp "o" "O" "[stdout prefix in listings]" \
    -errp "e" "E" "[stderr prefix in listings]" \
    -nosep "" "yes" "[deactivate separator between members]" \
    -preexec "" "" "[prefix program execution with this (time/gdb/...)]" \
    -packoutput "cat_output" "echo" "[]" \
    -worlds "0" "0" "[size of MPI worlds, 0=all processors available]" \
    -offset "0" "1" "[numbering of members from this value]" \
    -selftest "" "selftest.$$" "[quick selftest]" \
    ++ $*`
[[ -n ${inorder} ]] && processorder="yes"
[[ "${args}" == @* ]] && args2=${args#@} && [[ -f ${args2} ]] && args="$(xargs <${args2})"
#
# NOTE: -pgm @file option not implemented yet
# up to 5 items per line
# [directory] executable first_pe increment last_pe|@
# [directory] executable first_pe increment
# [directory] executable +number_of_pes
#
# -pgm syntax  (@ for last_pe means number of pes - 1)
# -pgm [directory] executable first_pe increment last_pe|@  (repeated)
# -pgm [directory] executable +number_of_pes (repeated)
#
[[ "${debug}" == full ]] && set -x
mkdir -p ${tmpdir}
export TMPDIR=${tmpdir}
#
if [[ -n ${selftest} ]] ; then
  selftest="${tmpdir}/${selftest}"
  pgm="${selftest}"
  cat <<EOT >${selftest}
#!/bin/ksh93
echo "NODE FILE='\${PBS_NODEFILE}' arguments:'\$@'"
echo "\$(hostname)(\${MP_CHILD}): RP_Child=\${RP_Child}, RP_Member=\${RP_Member}, RP_MemberChild=\${RP_MemberChild}, MP_SeqNum=\${MP_SeqNum}, RP_CommWorld=\${RP_CommWorld}"
set -x
[[ -x ${tmpdir}/mpi_c_test ]] && ${tmpdir}/mpi_c_test
rm ${tmpdir}/mpi_c_test
sleep \${1:-5}
EOT
 chmod 755 ${selftest}
 make_c_test
fi
#
export MpiRunScript=${tmpdir}/MpiRunScript_$$
export ParallelScript=${tmpdir}/ParallelScript_$$
touch ${ParallelScript}.0
[[ ! -r ${ParallelScript}.0 ]] && echo "ERROR: ${tmpdir} not a writable directory" 1>&2 && exit 1
#
export RedirectStdout="1>${tmpdir}/\${MP_SeqNum}/stdout"   # will be expanded at run time in ParallelScript
export RedirectStderr="2>${tmpdir}/\${MP_SeqNum}/stderr"   # will be expanded at run time in ParallelScript
[[ "${spliteo}" == no ]] && RedirectStderr="2>&1"
[[ -z ${processorder} ]] && RedirectStderr="" && RedirectStdout=""
#
(( npe_total=npex*npey ))
(( npe_total_m1=npe_total-1 ))
[[ "${worlds}" == 0 ]] && ((worlds=npe_total))
((MpiCommWorlds=0))
for i in ${worlds}
do
  PeInWorld[${MpiCommWorlds}]=${i}
  ((MpiCommWorlds=MpiCommWorlds+1))  # number of MPI comm worlds
done
#
export RPN_COMM_DOM=""
export RPN_COMM_DIRS="' '"
set -- $pgm ${MPIRUN_MPMD_PGM}
#
#export MpiCommWorld
#
if [[ "$2" != "" ]] ; then # complex sequence, possibly MPMD, possibly multiple MPI worlds
  ((ErRoR=0))
  for i in $(seq 0 1 ${npe_total_m1}) ; do ProGrams[$i]="NoNe" ; Directories[$i]="." ; done
  ((NDomains=0))
  ((Next=0))
  ((MpiCommWorld=0))
  while [[ "$1" != "" ]]
  do
    ((NDomains=NDomains+1))
    ((Instances=0))
    if [[ -d "$1" ]] ; then Directory="$1" ; shift ; else Directory="." ; fi
    Program="$1" ; shift ; echo Program=$Program
    if [[ !  -x "$Program" ]] ; then echo program $Program does not exist or is not executable ; ((ErRoR=ErRoR+1)) ; fi
    temp=${1:-0} 
    if [[ $temp = +* ]]
    then
       First=$Next
       Increment=1
       let Last=First+${temp#+}-1
       let Next=Last+1
       shift
    else
      First=$temp
      Increment=${2:-0}
      Last=${3:-${npe_total_m1}}
      if [[ "$Last" = "@" ]] ; then Last=${npe_total_m1} ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
    fi
    export RPN_COMM_DOM="$RPN_COMM_DOM,${First},${Increment},${Last}"
    export RPN_COMM_DIRS="$RPN_COMM_DIRS,'$Directory'"
    for i in $(seq ${First} ${Increment} ${Last} )
    do
      ((Instances=Instances+1))
      if [[ "${ProGrams[$i]}" != "NoNe" ]]
      then
        echo ERROR: duplicate program assignment "${ProGrams[$i]}" vs "$Program" in slot $i
        ((ErRoR=ErRoR+1))
      else
        ProGrams[$i]="$Program"
        Directories[$i]=$Directory
      fi
    done
    WorldSize[${NDomains}]=${Instances}
  done
  export RPN_COMM_DOM="${NDomains}${RPN_COMM_DOM}"
  rm -f ${MpirunScript}.${MpiCommWorld}
  for i in  $(seq 0 1 ${npe_total_m1})
  do
    if [[ !  -x "${ProGrams[$i]}" ]]
    then
      if [[ "${ProGrams[$i]}" = NoNe ]]
      then
        echo ERROR: no program specified for child $i
      else
        echo ${ProGrams[$i]} does not exist or is not executable "(child $i)"
      fi
      ((ErRoR=ErRoR+1))
    else
      echo "if [[ \"\${MP_CHILD}\" = \"$i\" ]] ; then ${preexec} ${ProGrams[$i]} ${args} ; fi" >>${MpiRunScript}.${MpiCommWorld}
    fi
  done
  if [[ "$ErRoR" != "0" ]] ; then echo "$ErRoR ERROR(S) detected" ; local_cleanup ; exit 1 ; fi
else # simple case with only one executable, one world (may allow one executable and multiple worlds later)
  if [[ ! -x $pgm ]] ; then
    echo $pgm does not exist or is not executable
    exit 1
  fi
  MpiCommWorld=0
  while ((MpiCommWorld<MpiCommWorlds))
  do
    echo ${preexec} $pgm $args >${MpiRunScript}.${MpiCommWorld}   # MpiCommWorld is 0 in this case
    ((MpiCommWorld=MpiCommWorld+1))
  done
fi
#
#######################################################################
MpiCommWorld=0
while ((MpiCommWorld<MpiCommWorlds))
do
#
  cat <<EOT >${ParallelScript}.${MpiCommWorld}
#!/bin/ksh93
[[ -n "${debug}" ]] && set -x
#
export MP_CHILD=\${MP_CHILD:-\${PMI_RANK:-\${OMPI_COMM_WORLD_RANK}}}  # poe/mpich2/openmpi
if [[ -z \${ENVIRONMENT_PASSED} ]] ; then
  cat >${tmpdir}/.mpi_env_\$\$_\$(hostname)
  . ${tmpdir}/.mpi_env_\$\$_\$(hostname)
fi
typeset -Z4 MP_SeqNum    # NOT VALID FOR bash, ksh family only
((MP_CHILD=MP_CHILD+ChildOffset))   # need to add ChildOffset for this MPI world to MP_CHILD (always 0 for poe)
export RP_CommWorld=${MpiCommWorld}
export MP_SeqNum="\$((MP_CHILD))"
export RP_Child="\$((MP_CHILD))"
export RP_Member=\$((MP_CHILD/${npex}+${offset}))
export RP_MemberChild=\$((MP_CHILD-MP_CHILD/${npex}*${npex}))
#env | sort >${tmpdir}/.mpi_env_\$\$_\$(hostname)
#
. ${MpiRunScript}.${MpiCommWorld}  ${RedirectStdout} ${RedirectStderr}
EOT
#
  chmod 755 ${ParallelScript}.${MpiCommWorld}
  ((MpiCommWorld=MpiCommWorld+1))
done
#######################################################################
echo "RPN_COMM_DOM=$RPN_COMM_DOM"
echo "RPN_COMM_DIRS=$RPN_COMM_DIRS"
#
rm -f $TMPDIR/PBS_NODEFILE
[[ -f "${GECOSHEP_HOSTS_FILE}" ]] && PBS_NODEFILE=${GECOSHEP_HOSTS_FILE}
if [[ -n ${PBS_NODEFILE} ]] ; then
  nhosts=$(sort -u ${PBS_NODEFILE} | wc -l | sed 's/ .*//')
  echo 
  ((loops=(npe_total+nhosts-1)/nhosts))
  for i in `sort -u < $PBS_NODEFILE`
  do
    for j in $(seq $loops)
    do
      echo ${i} >>${TMPDIR}/PBS_NODEFILE
    done
  done
else
  ((npe_temp=npe_total))
  while (( npe_temp > 0 )) ; do ((npe_temp=npe_temp-1)) ; echo $(hostname) >> ${TMPDIR}/PBS_NODEFILE ; done
fi
export PBS_NODEFILE=$TMPDIR/PBS_NODEFILE
# create stdout/stderr directories if necessary
if [[ -n ${processorder} ]] ; then
  for SeqNum in $(seq 0 1 ${npe_total_m1})
  do 
    mkdir ${tmpdir}/${SeqNum}
  done
  echo "=============================================="
  echo "temporary listings for all members in ${tmpdir}"
  echo "=============================================="
fi
#
if [[ ${nompi} == run_with_mpi ]] ; then  # MPI launch
#
  echo "${MPI_EXEC:-mpiexec.$(uname -s)} ${mpiargs}"
  ${MPI_EXEC:-mpiexec_$(uname -s)} ${mpiargs}
#
else   # background execution
#
  ((MP_CHILD=0))
  export MP_CHILD
  while ((MP_CHILD<npe_total))
  do
    ${ParallelScript} &
    ((MP_CHILD=MP_CHILD+1))
  done
  echo waiting for ${MP_CHILD} background tasks to terminate
  wait
#
fi
#
if [[ -n ${packoutput} && -n ${processorder} ]] ; then
  ( cd ${tmpdir} ; ${packoutput} [0-9]*[0-9] ; clean_output [0-9]*[0-9] )
fi
#
set +x
local_cleanup || true
