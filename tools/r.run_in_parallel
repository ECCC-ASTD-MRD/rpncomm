#!/bin/ksh93
#
# CAVEAT: this script uses typeset -Z (does not work for the bash shell)
typeset -Z4 SeqNum MemberNo MemberChild
#
# start of temporary code to deal with OLD mpich2 versions
#
kill_mpich2_mpd() {
  echo KILLING OLD INITIATORS IF ANY ARE FOUND
  for system in $(sort -u <${PBS_NODEFILE} | xargs) 
  do
    for target in $(ssh ${system}  ps -ef | grep /bin/mpd | grep python | grep ${USER} | sed -e s'/[ ][ ]*/ /g' | cut '-d ' -f 2) 
    do
      echo KILLING process ${target} on node ${system}
      ssh ${system} kill -9 ${target}
    done 
  done
}
start_mpich2_mpd() { # start mpd daemon(s)
  mpdboot -n $( sort -u <${PBS_NODEFILE} | wc -l ) -f ${PBS_NODEFILE}
  echo "mpd daemon(s) started"
}
stop_mpich2_mpd() {  # stop mpd daemon(s)
  mpdallexit
  echo "mpd daemon(s) stopped"
}
#
# end of temporary code to deal with OLD (pre 1.3) mpich2 versions
#
mpiexec_Linux() {
  ((MpiCommWorld>0)) && echo "ERROR: MpiCommWorld>0 not supported yet" && return
  mpirun --version 2>/dev/null 1>/dev/null || UseMpdboot=yes  # old mpich2 or no mpirun at all
  [[ -n $(which mpdboot 2>/dev/null) ]] || UseMpdboot=no      # mpdboot not found
  [[ "${UseMpdboot}" == yes ]] && echo "WARNING: using OLD version (pre 1.3) of mpich2 detected"
  [[ "${UseMpdboot}" == yes ]] && kill_mpich2_mpd     # needed temporarily for old mpich2 versions
  [[ "${UseMpdboot}" == yes ]] && start_mpich2_mpd    # needed temporarily for old mpich2 versions
  mpiexec -machinefile ${PBS_NODEFILE} -n ${PeInWorld[${MpiCommWorld}]} "$@" ${ParallelScript} ${MpiCommWorld}
  [[ "${UseMpdboot}" == yes ]] && stop_mpich2_mpd     # needed temporarily for old mpich2 versions
}
#
mpiexec_AIX() {
  ((MpiCommWorld>0)) && echo "ERROR: MpiCommWorld>0 not supported yet" && return
  if tty -s ; then
    export MP_PROCS=${PeInWorld[${MpiCommWorld}]}
    export MP_HOSTFILE=${PBS_NODEFILE}
#    grep -q $(hostname) ${HOME}/.rhosts 2>/dev/null || echo $(hostname) ${USER} >>${HOME}/.rhosts
#    chmod 700 ${HOME}/.rhosts
  fi
  export MP_NEWJOB=parallel
  export MP_WORLD_SIZES=${PeInWorld[${MpiCommWorld}]}
  poe "$@" ${ParallelScript} ${MpiCommWorld}
}
#
local_cleanup() {
 [[ -n ${nocleanup} ]] && return
 rm -f ${ParallelScript}* ${MP_HOSTFILE} ${MpiRunScript}* ${PBS_NODEFILE} ${selftest}
 rmdir ${tmpdir}
}
#
print_separator() {
  [[ -n ${nosep} ]] && return
  echo ===================      "$@"      ===================
}
#
cat_output() {  #  cat captured stdout/stderr files into stdout with appropriate tagging
#
  Prefix3="${errp}-"
  Prefix2="${outp}${errp}-"   # prepare for stderr not split from stdout
  [[ "${spliteo}" == yes ]] && Prefix2="${outp}-"
  [[ "${tag}" == none    ]] && Prefix="" && Prefix2="" && Prefix3=""
  [[ "${tag}" == stderr  ]] && Prefix="" && Prefix2="" && Prefix3="stderr: "
  for SeqNum in $* ; do 
    ((MemberNo=SeqNum/npey+offset))
    ((MemberChild=SeqNum-SeqNum/npey*npey))
    [[ "${tag}" == full   ]] && Prefix="${MemberNo}-${MemberChild}: "
    [[ "${tag}" == member ]] && Prefix="${MemberNo}: "
    [[ "${tag}" == child  ]] && Prefix="${SeqNum}: "
    [[ -r ${SeqNum}/stdout ]] && print_separator start stdout ${MemberNo}:${MemberChild} && cat ${SeqNum}/stdout | sed -e "s/^/${Prefix2}${Prefix}/"
    [[ -r ${SeqNum}/stderr ]] && print_separator start stderr ${MemberNo}:${MemberChild} && cat ${SeqNum}/stderr | sed -e "s/^/${Prefix3}${Prefix}/"
  done
  print_separator "   stdout / stderr   "
  print_separator " end of parallel run "
#
}
#
clean_output() {   #  get rid of captured stdout/stderr files into stdout
#
  [[ -n ${nocleanup} ]] && return
  for SeqNum in $* ; do 
    rm -f ${SeqNum}/std*
    rmdir ${SeqNum}
  done
#
}
#
echo version avec /bin/ksh
eval `cclargs_lite $0 \
    -tmpdir "$(pwd -P)/tmpdir" "" "[temporary directory visible by all processes]" \
    -pgm "Invalid_Command.EXE" "" "[]" \
    -args "" "" "[arguments to the command]" \
    -inorder "" "yes" "[list out/err of members in process order]" \
    -processorder "" "yes" "[list out/err of members in order]" \
    -spliteo "no" "yes" "[split stderr from stdout]" \
    -npex "${BATCH_MPI_CPUS:-1}" "" "[member size, total number of cpus if 1 member]" \
    -npey "1" "" "[number of members]" \
    -nompi "run_with_mpi" "run_in_background" "[]" \
    -mpiargs "" "" "[]" \
    -geometry "" "" "[]" \
    -debug "" "part" "[]" \
    -nocleanup "" "nocleanup" "[]" \
    -tag "child" "full" "[full/child/member/stderr/none]" \
    -outp "o" "O" "[stdout prefix in listings]" \
    -errp "e" "E" "[stderr prefix in listings]" \
    -nosep "" "yes" "[deactivate separator between members]" \
    -preexec "" "" "[prefix program execution with this (time/gdb/...)]" \
    -packoutput "cat_output" "echo" "[]" \
    -multiworld "no" "yes" "[launch each process in its own MPI world]" \
    -offset "0" "1" "[numbering of members from this value]" \
    -selftest "" "selftest.$$" "[quick selftest]" \
    ++ $*`
[[ -n ${inorder} ]] && processorder="yes"
[[ "${args}" == @* ]] && args2=${args#@} && [[ -f ${args2} ]] && args="$(xargs <${args2})"
#
# NOTE: -pgm @file option not implemented yet
# up to 5 items per line
# [directory] executable first_pe increment last_pe|@
# [directory] executable first_pe increment
# [directory] executable +number_of_pes
#
# -pgm syntax  (@ for last_pe means number of pes - 1)
# -pgm [directory] executable first_pe increment last_pe|@  (repeated)
# -pgm [directory] executable +number_of_pes (repeated)
#
[[ "${debug}" == full ]] && set -x
mkdir -p ${tmpdir}
export TMPDIR=${tmpdir}
if [[ -n ${selftest} ]] ; then
  selftest="${tmpdir}/${selftest}"
  pgm="${selftest}"
  cat <<EOT >${selftest}
#!/bin/ksh93
echo running on \$(hostname)
echo "arguments:'\$@'"
set -x
echo I am child \${RP_Child}, member \${RP_Member}, member child \${RP_MemberChild}, MP_SeqNum=\${MP_SeqNum}
EOT
 chmod 755 ${selftest}
fi
export MpiRunScript=${tmpdir}/MpiRunScript_$$
export ParallelScript=${tmpdir}/ParallelScript_$$
export RedirectStdout="1>${tmpdir}/\${MP_SeqNum}/stdout"   # will be expanded at run time in ParallelScript
export RedirectStderr="2>${tmpdir}/\${MP_SeqNum}/stderr"   # will be expanded at run time in ParallelScript
[[ "${spliteo}" == no ]] && RedirectStderr="2>&1"
[[ -z ${processorder} ]] && RedirectStderr="" && RedirectStdout=""
#
touch ${ParallelScript}
[[ ! -r ${ParallelScript} ]] && echo "ERROR: ${tmpdir} not a writable directory" 1>&2 && exit 1
#
(( npe_total=npex*npey ))
(( npe_total_m1=npe_total-1 ))
#
export RPN_COMM_DOM=""
export RPN_COMM_DIRS="' '"
set -- $pgm ${MPIRUN_MPMD_PGM}
#
export MpiCommWorld=0
PeInWorld[${MpiCommWorld}]=${npe_total}
#
if [[ "$2" != "" ]] ; then # complex sequence, possibly MPMD
  ((ErRoR=0))
  for i in $(seq 0 1 ${npe_total_m1}) ; do ProGrams[$i]="NoNe" ; Directories[$i]="." ; done
  ((NDomains=0))
  ((Next=0))
  while [[ "$1" != "" ]]
  do
    ((NDomains=NDomains+1))
    ((Instances=0))
    if [[ -d "$1" ]] ; then Directory="$1" ; shift ; else Directory="." ; fi
    Program="$1" ; shift ; echo Program=$Program
    if [[ !  -x "$Program" ]] ; then echo program $Program does not exist or is not executable ; ((ErRoR=ErRoR+1)) ; fi
    temp=${1:-0} 
    if [[ $temp = +* ]]
    then
       First=$Next
       Increment=1
       let Last=First+${temp#+}-1
       let Next=Last+1
       shift
    else
      First=$temp
      Increment=${2:-0}
      Last=${3:-${npe_total_m1}}
      if [[ "$Last" = "@" ]] ; then Last=${npe_total_m1} ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
    fi
    export RPN_COMM_DOM="$RPN_COMM_DOM,${First},${Increment},${Last}"
    export RPN_COMM_DIRS="$RPN_COMM_DIRS,'$Directory'"
    for i in $(seq ${First} ${Increment} ${Last} )
    do
      ((Instances=Instances+1))
      if [[ "${ProGrams[$i]}" != "NoNe" ]]
      then
        echo ERROR: duplicate program assignment "${ProGrams[$i]}" vs "$Program" in slot $i
        ((ErRoR=ErRoR+1))
      else
        ProGrams[$i]="$Program"
        Directories[$i]=$Directory
      fi
    done
    WorldSize[${NDomains}]=${Instances}
  done
  export RPN_COMM_DOM="${NDomains}${RPN_COMM_DOM}"
  rm -f ${MpirunScript}.${MpiCommWorld}
  for i in  $(seq 0 1 ${npe_total_m1})
  do
    if [[ !  -x "${ProGrams[$i]}" ]]
    then
      if [[ "${ProGrams[$i]}" = NoNe ]]
      then
        echo ERROR: no program specified for child $i
      else
        echo ${ProGrams[$i]} does not exist or is not executable "(child $i)"
      fi
      ((ErRoR=ErRoR+1))
    else
      echo "if [[ \"\${MP_CHILD}\" = \"$i\" ]] ; then ${preexec} ${ProGrams[$i]} ${args} ; fi" >>${MpiRunScript}.${MpiCommWorld}
    fi
  done
  if [[ "$ErRoR" != "0" ]] ; then echo "$ErRoR ERROR(S) detected" ; local_cleanup ; exit 1 ; fi
else # simple case with only one executable
  if [[ ! -x $pgm ]] ; then
    echo $pgm does not exist or is not executable
    exit 1
  fi
  echo ${preexec} $pgm $args >${MpiRunScript}.${MpiCommWorld}
fi
#
#######################################################################
cat <<EOT >${ParallelScript}
#!/bin/ksh93
[[ -n "${debug}" ]] && set -x
#
typeset -Z4 MP_SeqNum    # NOT VALID FOR bash, ksh family only
export MP_CHILD=\${MP_CHILD:-\${PMI_RANK:-\${OMPI_COMM_WORLD_RANK}}}  # poe/mpich2/openmpi
export MP_SeqNum="\$((MP_CHILD))"
export RP_Child="\$((MP_CHILD))"
export RP_Member=\$((MP_CHILD/${npey}+${offset}))
export RP_MemberChild=\$((MP_CHILD-MP_CHILD/${npey}*${npey}))
#
. ${MpiRunScript}.\${1:-0}  ${RedirectStdout} ${RedirectStderr}
EOT
#######################################################################
chmod 755 ${ParallelScript}
echo "RPN_COMM_DOM=$RPN_COMM_DOM"
echo "RPN_COMM_DIRS=$RPN_COMM_DIRS"
#
rm -f $TMPDIR/PBS_NODEFILE
if [[ -n ${PBS_NODEFILE} ]] ; then
  nhosts=$(sort -u ${PBS_NODEFILE} | wc -l | sed 's/ .*//')
  echo 
  ((loops=(npe_total+nhosts-1)/nhosts))
  for i in `sort -u < $PBS_NODEFILE`
  do
    for j in $(seq $loops)
    do
      echo ${i} >>${TMPDIR}/PBS_NODEFILE
    done
  done
else
  ((npe_temp=npe_total))
  while (( npe_temp > 0 )) ; do ((npe_temp=npe_temp-1)) ; echo $(hostname) >> ${TMPDIR}/PBS_NODEFILE ; done
fi
export PBS_NODEFILE=$TMPDIR/PBS_NODEFILE
# create stdout/stderr directories if necessary
if [[ -n ${processorder} ]] ; then
  for SeqNum in $(seq 0 1 ${npe_total_m1})
  do 
    mkdir ${tmpdir}/${SeqNum}
  done
  echo "=============================================="
  echo "temporary listings for all members in ${tmpdir}"
  echo "=============================================="
fi
#
if [[ ${nompi} == run_with_mpi ]] ; then  # MPI launch
#
  echo "${MPI_EXEC:-mpiexec.$(uname -s)} ${mpiargs}"
  ${MPI_EXEC:-mpiexec_$(uname -s)} ${mpiargs}
#
else   # background execution
#
  ((MP_CHILD=0))
  export MP_CHILD
  while ((MP_CHILD<npe_total))
  do
    ${ParallelScript} &
    ((MP_CHILD=MP_CHILD+1))
  done
  echo waiting for ${MP_CHILD} background tasks to terminate
  wait
#
fi
#
if [[ -n ${packoutput} && -n ${processorder} ]] ; then
  ( cd ${tmpdir} ; ${packoutput} [0-9]*[0-9] ; clean_output [0-9]*[0-9] )
fi
#
set +x
local_cleanup
