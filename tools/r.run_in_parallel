#!/bin/ksh93
# this script is the successor to the r.mpirun... series of scripts with expanded functionality
# (stdout/stderr post processing and "launch in background" capability)
#
# CAVEAT: this script uses typeset -Z (does not work for the bash shell)
typeset -Z4 SeqNum MemberNo MemberChild
# ===========================================================================
# start of temporary code to deal with OLD mpich2 versions needing mpdboot
#
kill_mpich2_mpd() {
  echo KILLING OLD INITIATORS IF ANY ARE FOUND
  for system in $(sort -u <${PBS_NODEFILE} | xargs) 
  do
    for target in $(ssh ${system}  ps -ef | grep /bin/mpd | grep python | grep ${USER} | sed -e s'/[ ][ ]*/ /g' | cut '-d ' -f 2) 
    do
      echo KILLING process ${target} on node ${system}
      ssh ${system} kill -9 ${target}
    done 
  done
}
start_mpich2_mpd() { # start mpd daemon(s)
  mpdboot -n $( sort -u <${PBS_NODEFILE} | wc -l ) -f ${PBS_NODEFILE}
  echo "mpd daemon(s) started"
}
stop_mpich2_mpd() {  # stop mpd daemon(s)
  mpdallexit
  echo "mpd daemon(s) stopped"
}
#
# end of temporary code to deal with OLD mpich2 versions needing mpdboot
# ===========================================================================
mpiexec_Linux() {
  export ENVIRONMENT_PASSED=yes
#  ((MpiCommWorlds>1)) && echo "ERROR: MpiCommWorlds>1 not supported yet" && return
#
# we are assuming that mpirun/mpiexec can be backgrounded.
# should this assumption be false the top line must be uncommented
#
# start of temporary code to deal with OLD mpich2 versions needing mpdboot
#
  mpirun --version 2>/dev/null 1>/dev/null || UseMpdboot=yes  # old mpich2 or no mpirun at all
  [[ -n $(which mpdboot 2>/dev/null) ]] || UseMpdboot=no      # mpdboot not found
  [[ "${UseMpdboot}" == yes ]] && echo "WARNING: using OLD version (pre 1.3) of mpich2 detected"
  [[ "${UseMpdboot}" == yes ]] && kill_mpich2_mpd     # needed temporarily for old mpich2 versions
  [[ "${UseMpdboot}" == yes ]] && start_mpich2_mpd    # needed temporarily for old mpich2 versions
#
# end of temporary code to deal with OLD mpich2 versions needing mpdboot
#
  if [[ "${OPAL_PREFIX}" == *openmpi_1.6* ]] ; then
    OPEN_MPI_PARMS="--prefix ${OPAL_PREFIX} --stdin all --mca btl tcp,self --cpus-per-proc ${OMP_NUM_THREADS:-1}"
    unset PE_HOSTFILE
#    export OMPI_MCA_orte_default_hostfile=${PBS_NODEFILE}
    [[ -f "${GECOSHEP_HOSTS_FILE}" ]] && export OMPI_MCA_orte_rsh_agent=rurun
    export OMPI_MCA_plm_rsh_disable_qrsh=1
  fi
#
  touch tmpdir/.mpi_env
  export MpiCommWorld=0
  export ChildOffset=0
  HostOffset=0
  PBS_NODEFILE_ORI=${PBS_NODEFILE}
  while(( MpiCommWorld<MpiCommWorlds)) ; do
#
    echo ===== MPI host file for MpiCommWorld=$MpiCommWorld =====
    ((FirstHost=HostOffset+1))
    ((HostOffset=HostOffset+${PeInWorld[${MpiCommWorld}]}))
    export PBS_NODEFILE=${PBS_NODEFILE_ORI}.${MpiCommWorld}
    sed -n ${FirstHost},${HostOffset}p ${PBS_NODEFILE_ORI} >${PBS_NODEFILE}
    cat ${PBS_NODEFILE}
    echo ===== MPI host file =====
#
    [[ "${OPAL_PREFIX}" == *openmpi_1.6* ]] && \
       env | grep -v "'" | grep -v '"' | grep  '^[a-zA-Z0-9]' | sed -e 's/^/export /' -e 's/=/="/' -e 's/$/"/' >tmpdir/.mpi_env
#
    if ((MpiCommWorlds>1)) ; then
      echo ==== Backgrounding MPI world ${MpiCommWorld} with ${PeInWorld[${MpiCommWorld}]} MPI tasks ====
      cat tmpdir/.mpi_env | \
      mpirun ${OPEN_MPI_PARMS} -machinefile ${PBS_NODEFILE} -n ${PeInWorld[${MpiCommWorld}]} "$@" ${ParallelScript}.${MpiCommWorld} &
    else
      echo ==== Launching MPI world ${MpiCommWorld} with ${PeInWorld[${MpiCommWorld}]} MPI tasks ====
      cat tmpdir/.mpi_env | \
      mpirun ${OPEN_MPI_PARMS} -machinefile ${PBS_NODEFILE} -n ${PeInWorld[${MpiCommWorld}]} "$@" ${ParallelScript}.${MpiCommWorld}
    fi
    PeAdded=${PeInWorld[${MpiCommWorld}]}
    ((ChildOffset=ChildOffset+PeAdded))
    ((MpiCommWorld=MpiCommWorld+1))
  done
  ((MpiCommWorlds>1)) && \
  echo ==== Waiting for ${MpiCommWorlds} MPI worlds to terminate ==== && \
  wait
#
  [[ "${UseMpdboot}" == yes ]] && stop_mpich2_mpd     # needed temporarily for OLD mpich2 versions that need mpdboot
}
# ===========================================================================
mpiexec_AIX() {
  export ENVIRONMENT_PASSED=yes
#  ((MpiCommWorlds>1)) && echo "ERROR: MpiCommWorlds>1 not supported yet" && return
  ((MpiCommWorld=0))
  if tty -s ; then  # node list only necessary in interactive case
    echo "INFO: interactive use of MPI on AIX"
    export MP_PROCS
    export MP_HOSTFILE=${PBS_NODEFILE}
    grep -q $(hostname) ${HOME}/.rhosts 2>/dev/null || echo $(hostname) ${USER} >>${HOME}/.rhosts
    chmod 700 ${HOME}/.rhosts
  fi
  rm -f ${ParallelScript}.ALL
  ((MP_PROCS=0))
  while(( MpiCommWorld<MpiCommWorlds)) ; do
    echo "${ParallelScript}.${MpiCommWorld}@$((MpiCommWorld+1))%${PeInWorld[${MpiCommWorld}]}%mpi:*" >>${ParallelScript}.ALL
    ((MP_PROCS=MP_PROCS+${PeInWorld[${MpiCommWorld}]}))
    ((MpiCommWorld=MpiCommWorld+1))
  done
  export MP_NEWJOB=parallel
  export ChildOffset=0   # poe takes care of adjusting MP_CHILD
#  export MP_WORLD_SIZES=${PeInWorld[${MpiCommWorld}]}
#  poe "$@" ${ParallelScript}.${MpiCommWorld} </dev/null
  echo MP_PROCS=${MP_PROCS}
  echo "COMPLETE" >>${ParallelScript}.ALL
  echo "========== poe command file with ${MP_PROCS} tasks =========="
  cat ${ParallelScript}.ALL
  poe -cmdfile ${ParallelScript}.ALL </dev/null
  echo POE command COMPLETE
}
# ===========================================================================
local_cleanup() {
 [[ -n ${nocleanup} ]] && return
 rm -f ${ParallelScript}* ${MP_HOSTFILE} ${MpiRunScript}* ${tmpdir}/PBS_NODEFILE* ${selftest} ${tmpdir}/.mpi_env*
 rmdir ${tmpdir} || true
 [[ -d "${tmpdir}" ]] && \
 echo INFO: leftovers found in ${tmpdir} && \
 ls -al ${tmpdir} && \
 rm -rf ${tmpdir}  && \
 echo removing everything in ${tmpdir}
}
# ===========================================================================
print_separator() {
  [[ -n ${nosep} ]] && return
  echo ===================      "$@"      ===================
}
# ===========================================================================
cat_output() {  #  cat captured stdout/stderr files into stdout with appropriate tagging
#
  Prefix3="${errp}-"
  Prefix2="${outp}${errp}-"   # prepare for stderr not split from stdout
  [[ "${spliteo}" == yes ]] && Prefix2="${outp}-"
  [[ "${tag}" == none    ]] && Prefix="" && Prefix2="" && Prefix3=""
  [[ "${tag}" == stderr  ]] && Prefix="" && Prefix2="" && Prefix3="stderr: "
  for SeqNum in $* ; do 
    ((MemberNo=SeqNum/npex+offset))
    ((MemberChild=SeqNum-SeqNum/npex*npex))
    [[ "${tag}" == full   ]] && Prefix="${MemberNo}-${MemberChild}: "
    [[ "${tag}" == member ]] && Prefix="${MemberNo}: "
    [[ "${tag}" == child  ]] && Prefix="${SeqNum}: "
    [[ -r ${SeqNum}/stdout ]] && print_separator start stdout ${MemberNo}:${MemberChild} && cat ${SeqNum}/stdout | sed -e "s/^/${Prefix2}${Prefix}/"
    [[ -r ${SeqNum}/stderr ]] && print_separator start stderr ${MemberNo}:${MemberChild} && cat ${SeqNum}/stderr | sed -e "s/^/${Prefix3}${Prefix}/"
  done
  print_separator "   stdout / stderr   "
  print_separator " end of parallel run "
}
# ===========================================================================
clean_output() {   #  get rid of captured stdout/stderr files into stdout
#
  [[ -n ${nocleanup} ]] && return
  for SeqNum in $* ; do 
    rm -f ${SeqNum}/std*
    rmdir ${SeqNum}
  done
}
# ===========================================================================
make_c_test() {
echo INFO: creating C test program source mpi_c_test.c
cat >${tmpdir}/mpi_c_test.c <<EOT
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <mpi.h>

void main(int argc, char **argv)
{
 int my_rank=-1;
 char hostname[1204];

 gethostname(hostname, 1023);
 MPI_Init(&argc,&argv);
 MPI_Comm_rank(MPI_COMM_WORLD , &my_rank);
 printf("host = %s, rank = %d \n",hostname,my_rank);
 MPI_Finalize();
}
EOT
echo INFO: compiling C test program mpi_c_test.c into mpi_c_test
which mpicc 2>/dev/null 1>/dev/null && mpicc -o ${tmpdir}/mpi_c_test ${tmpdir}/mpi_c_test.c
which mpcc 2>/dev/null 1>/dev/null && mpcc -o ${tmpdir}/mpi_c_test ${tmpdir}/mpi_c_test.c
echo INFO: removing C test program source mpi_c_test.c
rm ${tmpdir}/mpi_c_test.c
}
# ===========================================================================
# remap_nodes , uses node file and geometry file
# usage: remap_nodes > new_reordered_node_list
remap_pass2() {
  ((Host=-1))
  while read Line
  do
    ((Host=Host+1))
    for i in $Line
    do
      echo $i ${HostList[$Host]} # task_number host_name
    done
  done
}
remap_nodes() {
  [[ -r "${PBS_NODEFILE}" && -r "${geometry}" ]] || return 1
  ((Host=-1))
  for i in $(uniq ${PBS_NODEFILE}) # build list of host names
  do
   ((Host=Host+1))
   HostList[$Host]=$i
  done
  cat ${geometry} | pass2 | sort -n | cut '-d ' -f2
}
remap_nodes() {
  [[ -r "${PBS_NODEFILE}" && -r "${geometry}" ]] || exit 1
  remap_pass1 ${PBS_NODEFILE} ${geometry}
}
# ===========================================================================
# prepare full node list (parts of it to be used by each MPI wolrd)
# -geometry processing will only work with openmpi/linux
# in that case a node file will be expected with as many nodes as there
# are lines in the geometry file
# under AIX the remapping is expected to be performed by the LoadLeveler
# geometry keyword in the job header
# all this will have to be revisited in the future in order to support 
# heterogenous OpenMP factors (probably using the geometry)
# OMP_NUM_THREADS consistency with computed "loops" is not checked
# the master node is kept at the beginning of the node list
# this is why 'sort -u' has been replaced with 'uniq'
#
make_node_file() {   # this will be rewritten
  # if there is a geometry file, remap the node list file
  # remapping will fail if there is no node file pointed to by PBS_NODEFILE
  [[ -f "${geometry}" ]] && \
     remap_nodes > $TMPDIR/PBS_NODEFILE && \
     export PBS_NODEFILE=$TMPDIR/PBS_NODEFILE && \
     return
  rm -f $TMPDIR/PBS_NODEFILE
  if [[ -n ${PBS_NODEFILE} ]] ; then  # node file supplied via PBS_NODEFILE
    nhosts=$(sort -u ${PBS_NODEFILE} | wc -l | sed 's/ .*//')   # number of hosts
    ((loops=(npe_total+nhosts-1)/nhosts))   # number of tasks per host
    for i in $(uniq < $PBS_NODEFILE)
    do
      for j in $(seq $loops)
      do
	echo ${i} >>${TMPDIR}/PBS_NODEFILE   # one entry per task
      done
    done
  else  # no node file supplied, if interactive create one
    if tty -s ; then   # interactive,
      ((npe_temp=npe_total))
      while (( npe_temp > 0 )) ; do ((npe_temp=npe_temp-1)) ; echo $(hostname) >> ${TMPDIR}/PBS_NODEFILE ; done
    fi
  fi
  export PBS_NODEFILE=$TMPDIR/PBS_NODEFILE
}
# ===========================================================================
echo version avec /bin/ksh93
eval `cclargs_lite $0 \
    -tmpdir "$(pwd -P)/tmpdir" "" "[temporary directory visible by all processes]" \
    -pgm "Invalid_Command.EXE" "" "[]" \
    -args "" "" "[arguments to the command]" \
    -inorder "" "yes" "[list out/err of members in process order]" \
    -processorder "" "yes" "[list out/err of members in order]" \
    -spliteo "no" "yes" "[split stderr from stdout]" \
    -npex "${BATCH_MPI_CPUS:-1}" "" "[member size, total number of cpus if 1 member]" \
    -npey "1" "" "[number of members]" \
    -nompi "run_with_mpi" "run_in_background" "[]" \
    -mpiargs "" "" "[]" \
    -geometry "" "" "[]" \
    -debug "" "part" "[]" \
    -nocleanup "" "nocleanup" "[]" \
    -tag "child" "full" "[full/child/member/stderr/none]" \
    -outp "o" "O" "[stdout prefix in listings]" \
    -errp "e" "E" "[stderr prefix in listings]" \
    -nosep "" "yes" "[deactivate separator between members]" \
    -preexec "" "" "[prefix program execution with this (time/gdb/...)]" \
    -packoutput "cat_output" "echo" "[]" \
    -worlds "0" "0" "[size of MPI worlds, 0=all processors available]" \
    -offset "0" "1" "[numbering of members from this value]" \
    -selftest "" "selftest.$$" "[quick selftest]" \
    ++ $*`
[[ -n ${inorder} ]] && processorder="yes"
# process -args @file
[[ "${args}" == @* ]] && args2=${args#@} && [[ -f ${args2} ]] && args="$(xargs <${args2})"
# args variable now contains all programs
#
# -pgm @file 
# up to 5 items per line (same syntax as -pgm)
# [directory] executable first_pe increment last_pe|@
# [directory] executable first_pe increment
# [directory] executable +number_of_pes
#
# -pgm syntax  (@ for last_pe means number of pes - 1)
# -pgm [directory] executable first_pe increment last_pe|@  (repeated)
# -pgm [directory] executable +number_of_pes (repeated)
#
# process -pgm @file
[[ "${pgm}" == @* ]] && pgm2=${pgm#@} && [[ -f ${pgm2} ]] && pgm="$(xargs <${pgm2})"
# pgm variable now contains all taht is needed
#
[[ "${debug}" == full ]] && set -x
# reset TMPDIR to make sure it is visible to all MPI tasks
mkdir -p ${tmpdir}
export TMPDIR=${tmpdir}
#
# create script anc C program used in self test if needed
#
if [[ -n ${selftest} ]] ; then
  selftest="${tmpdir}/${selftest}"
  pgm="${selftest}"
  cat <<EOT >${selftest}
#!/bin/ksh93
echo "NODE FILE='\${PBS_NODEFILE}' arguments:'\$@'"
echo "\$(hostname)(\${MP_CHILD}): RP_Child=\${RP_Child}, RP_Member=\${RP_Member}, RP_MemberChild=\${RP_MemberChild}, MP_SeqNum=\${MP_SeqNum}, RP_CommWorld=\${RP_CommWorld}"
set -x
[[ -x ${tmpdir}/mpi_c_test ]] && ${tmpdir}/mpi_c_test
rm ${tmpdir}/mpi_c_test
sleep \${1:-5}
EOT
 chmod 755 ${selftest}
 make_c_test
fi
#
# primary and secondary launching scripts
#
export MpiRunScript=${tmpdir}/MpiRunScript_$$
export ParallelScript=${tmpdir}/ParallelScript_$$
touch ${ParallelScript}.0
[[ ! -r ${ParallelScript}.0 ]] && echo "ERROR: ${tmpdir} not a writable directory" 1>&2 && exit 1
#
# stdout and stderr redirection
#
export RedirectStdout="1>${tmpdir}/\${MP_SeqNum}/stdout"   # will be expanded at run time in ParallelScript
export RedirectStderr="2>${tmpdir}/\${MP_SeqNum}/stderr"   # will be expanded at run time in ParallelScript
[[ "${spliteo}" == no ]] && RedirectStderr="2>&1"
[[ -z ${processorder} ]] && RedirectStderr="" && RedirectStdout=""
#
# number of PEs and MPI worlds
#
(( npe_total=npex*npey ))
(( npe_total_m1=npe_total-1 ))
[[ "${worlds}" == 0 ]] && ((worlds=npe_total))
((MpiCommWorlds=0))
for i in ${worlds}
do
  PeInWorld[${MpiCommWorlds}]=${i}
  ((MpiCommWorlds=MpiCommWorlds+1))  # number of MPI comm worlds
done
#
# communication variables for RPN_COMM toolkit
#
export RPN_COMM_DOM=""
export RPN_COMM_DIRS="' '"
set -- $pgm ${MPIRUN_MPMD_PGM}
#
if [[ "$2" != "" ]] ; then # complex sequence, possibly MPMD, (automatic multiple MPI worlds not implemented yet)
  ((ErRoR=0))
  for i in $(seq 0 1 ${npe_total_m1}) ; do ProGrams[$i]="NoNe" ; Directories[$i]="." ; done
  ((NDomains=0))
  ((Next=0))
  ((MpiCommWorld=0))
  while [[ "$1" != "" ]]
  do
    ((NDomains=NDomains+1))
    ((Instances=0))
    if [[ -d "$1" ]] ; then Directory="$1" ; shift ; else Directory="." ; fi
    Program="$1" ; shift ; echo Program=$Program
    if [[ !  -x "$Program" ]] ; then echo program $Program does not exist or is not executable ; ((ErRoR=ErRoR+1)) ; fi
    temp=${1:-0} 
    if [[ $temp = +* ]]
    then
       First=$Next
       Increment=1
       let Last=First+${temp#+}-1
       let Next=Last+1
       shift
    else
      First=$temp
      Increment=${2:-0}
      Last=${3:-${npe_total_m1}}
      if [[ "$Last" = "@" ]] ; then Last=${npe_total_m1} ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
      if [[ "$1" != "" ]] ; then shift ; fi
    fi
    export RPN_COMM_DOM="$RPN_COMM_DOM,${First},${Increment},${Last}"
    export RPN_COMM_DIRS="$RPN_COMM_DIRS,'$Directory'"
    for i in $(seq ${First} ${Increment} ${Last} )
    do
      ((Instances=Instances+1))
      if [[ "${ProGrams[$i]}" != "NoNe" ]]
      then
        echo ERROR: duplicate program assignment "${ProGrams[$i]}" vs "$Program" in slot $i
        ((ErRoR=ErRoR+1))
      else
        ProGrams[$i]="$Program"
        Directories[$i]=$Directory
      fi
    done
    WorldSize[${NDomains}]=${Instances}
  done
  export RPN_COMM_DOM="${NDomains}${RPN_COMM_DOM}"
  rm -f ${MpirunScript}.${MpiCommWorld}
  for i in  $(seq 0 1 ${npe_total_m1})
  do
    if [[ !  -x "${ProGrams[$i]}" ]]
    then
      if [[ "${ProGrams[$i]}" = NoNe ]]
      then
        echo ERROR: no program specified for child $i
      else
        echo ${ProGrams[$i]} does not exist or is not executable "(child $i)"
      fi
      ((ErRoR=ErRoR+1))
    else
      echo "if [[ \"\${MP_CHILD}\" = \"$i\" ]] ; then ${preexec} ${ProGrams[$i]} ${args} ; fi" >>${MpiRunScript}.${MpiCommWorld}
    fi
  done
  if [[ "$ErRoR" != "0" ]] ; then echo "$ErRoR ERROR(S) detected" ; local_cleanup ; exit 1 ; fi
else # simple case with only one executable, one or more MPI worlds
  if [[ ! -x $pgm ]] ; then
    echo $pgm does not exist or is not executable
    exit 1
  fi
  MpiCommWorld=0
  while ((MpiCommWorld<MpiCommWorlds)) # same executable for all worlds
  do
    echo ${preexec} $pgm $args >${MpiRunScript}.${MpiCommWorld}   # MpiCommWorld is 0 in this case
    ((MpiCommWorld=MpiCommWorld+1))
  done
fi
#
# prepare primary launch scripts (one per world)
#
MpiCommWorld=0
while ((MpiCommWorld<MpiCommWorlds))
do
#
  cat <<EOT >${ParallelScript}.${MpiCommWorld}
#!/bin/ksh93
[[ -n "${debug}" ]] && set -x
#
export MP_CHILD=\${MP_CHILD:-\${PMI_RANK:-\${OMPI_COMM_WORLD_RANK}}}  # poe/mpich2/openmpi
if [[ -z \${ENVIRONMENT_PASSED} ]] ; then
  cat >${tmpdir}/.mpi_env_\$\$_\$(hostname)
  . ${tmpdir}/.mpi_env_\$\$_\$(hostname)
fi
typeset -Z4 MP_SeqNum    # NOT VALID FOR bash, ksh family only
((MP_CHILD=MP_CHILD+ChildOffset))   # need to add ChildOffset for this MPI world to MP_CHILD (always 0 for poe)
export RP_CommWorld=${MpiCommWorld}
export MP_SeqNum="\$((MP_CHILD))"
export RP_Child="\$((MP_CHILD))"
export RP_Member=\$((MP_CHILD/${npex}+${offset}))
export RP_MemberChild=\$((MP_CHILD-MP_CHILD/${npex}*${npex}))
#env | sort >${tmpdir}/.mpi_env_\$\$_\$(hostname)
#
. ${MpiRunScript}.${MpiCommWorld}  ${RedirectStdout} ${RedirectStderr}
EOT
#
  chmod 755 ${ParallelScript}.${MpiCommWorld}
  ((MpiCommWorld=MpiCommWorld+1))
done
#
# we are now almost ready to launch
#
echo "RPN_COMM_DOM=$RPN_COMM_DOM"
echo "RPN_COMM_DIRS=$RPN_COMM_DIRS"
#
#make_node_file
#
rm -f $TMPDIR/PBS_NODEFILE
[[ -f "${GECOSHEP_HOSTS_FILE}" ]] && PBS_NODEFILE=${GECOSHEP_HOSTS_FILE}
if [[ -n ${PBS_NODEFILE} ]] ; then  # node file supplied via PBS_NODEFILE or GECOSHEP_HOSTS_FILE
  nhosts=$(sort -u ${PBS_NODEFILE} | wc -l | sed 's/ .*//')
  echo 
  ((loops=(npe_total+nhosts-1)/nhosts))  # we assume an equal number of MPI tasks per node
  for i in `sort -u < $PBS_NODEFILE`
  do
    for j in $(seq $loops)
    do
      echo ${i} >>${TMPDIR}/PBS_NODEFILE
    done
  done
else  # no node file supplied via PBS_NODEFILE or GECOSHEP_HOSTS_FILE environment variable
  ((npe_temp=npe_total))
  while (( npe_temp > 0 )) ; do ((npe_temp=npe_temp-1)) ; echo $(hostname) >> ${TMPDIR}/PBS_NODEFILE ; done
fi
#
# from now on PBS_NODEFILE is the node file
#
export PBS_NODEFILE=$TMPDIR/PBS_NODEFILE
# create stdout/stderr directories if necessary
if [[ -n ${processorder} ]] ; then
  for SeqNum in $(seq 0 1 ${npe_total_m1})
  do 
    mkdir ${tmpdir}/${SeqNum}
  done
  echo "=============================================="
  echo "temporary listings for all members in ${tmpdir}"
  echo "=============================================="
fi
#
if [[ ${nompi} == run_with_mpi ]] ; then  # MPI launch (linux or AIX supported)
#
  echo "${MPI_EXEC:-mpiexec.$(uname -s)} ${mpiargs}"
  ${MPI_EXEC:-mpiexec_$(uname -s)} ${mpiargs}
#
else   # background launch
#
  ((MP_CHILD=0)) # MP_CHILD used to indicate logical child number (like MPI case)
  export MP_CHILD
  while ((MP_CHILD<npe_total))
  do
    ${ParallelScript} &
    ((MP_CHILD=MP_CHILD+1))
  done
  echo waiting for ${MP_CHILD} background tasks to terminate
  wait
#
fi
#
# post process/order listings if required
#
if [[ -n ${packoutput} && -n ${processorder} ]] ; then
  ( cd ${tmpdir} ; ${packoutput} [0-9]*[0-9] ; clean_output [0-9]*[0-9] )
fi
#
set +x
local_cleanup || true
